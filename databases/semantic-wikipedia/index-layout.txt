---------------------------------------------------------------------------------
----------------------  The Indexes used by Broccoli ----------------------------
---------------------------------------------------------------------------------

-------------------------------- OVERVIEW ---------------------------------------

The Broccoli backend uses a set of indexes:

1. ONE Ontology Index. Changes to the ontology may require rebuilding all
full-text indexes. In particular, the ontology vocabulary assigns IDs to
entities that may occur in text indexes.

2. Multiple Full-text Indexes. Different indexes each have their own vocabulary
and indexed documents are assumed to be disjoint. In particular, two documents
from different indexes will be treated as different documents under all
circumstances.

Each index consits of a large part of data, followed by meta-data that contains
important offsets in the prior part of the index. This meta data is read on
startup and henceforth the Index class exposes an API to access index lists from
either ontology or full-text index programmatically and without worrying about
the actual file.


------------------------------ ONTOLOGY INDEX -----------------------------------

The Ontology Index contains information from the ontology. In particular, a set
of realtions between entities. The overall layout is like this:

<relation_1><realtion_2>....<realtion_n><metaData><offset:startOfMetaData> 

While:
    <relation_i>         := <relationBlock_1>...<realtionBlock_m>
    <realtionBlock_i>    := <LeftHandSide-Ids><rightHandSide-Ids>
    <metaData>           := <relMetaData_1>...<relMetaData_n>  
    <relationMetaData_i> := <relId><lhsType><rhsType><rBlockMetaData_1>...<rBlockMetaData_m>      
    <rBlockMetaData_i>   := <maxLhs><nofElements><startOfLhs><startOfRhs><posOfLastRhs> 

    NOTE: using a <posOfLastRhs> probably was a bad idea and will have to be
    changed as soon as compressin is used.


Reversed Relations and sorting order:

All non-special (see below) relations are indexed twice. Once in the natural
way, and once reversed. 
E.g. one entry of the born-in relation has a left-hand-side Albert_Einstein
and a right-hand-side Ulm. The relation born-in_(reversed) contains this element
the other way round. I.e. lhs: Ulm, rhs: Albert_Einstein.
Reason: Relations in the index are always sorted by left-hand-side. If a
relation has to accessed efficiently through its right-hand-side, the reversed
pendant can be used instead.


Blocks:

Not all relations for spilt over several block. However, sometimes it is really
convenient. Especially for the reversed is-a relation, this is really useful.
However, it might makemore sense to only saves right-hand-sides of the reversed
is-a relation, since the left-hand-side is irrelevant as soon as there is a
block for each class. This is a TODO for the future (Dec 2011).
Transitive Realtions:


Transitivity:

The index does not treat transitivity rules. It is assumed that transitive
closures of relations are built before sending the ontology to the index
builder (when desired).


Special Relations:

There are special realtions that do not occur explicitly in the ontology.
Currently the index features:
 
1. Relation: "has-relations"
    The relation "has-realtions" is built from the whle ontology and has entries
    of the form "entity - realtion". For each entity in the ontology it lists
    all relations in which this entity occurs as left-hand-side. This means
    Albert_Einstein has realtion (amongst many) "born-in" and Ulm
    has relation "born-in_(reversed)". Since this relation is only needed to
    display the realtions box which means it is accessed thorugh a list of
    entities, no reversed direction is necessary and therefore none is built and
    contained in the index. Special relations, like "has-relations" itself, are
    not included.
    Apart from that, having the "is-a" relation is not intersting as every
    entity is-a entity (the class). Since this relation does have lots of
    entries, excluding it from the "has-relations" relation, is both convenient
    and useful w.r.t. efficiency. 

2. Relation: "has-instances"
    The relation "has-instances" is build from an additional input file
    currently called "ontology.abstractness-counts", although all information
    could be derived from the actual relations. Since this file is required
    as input for the parser, it has to be built anyway and it is just convenient
    to use it. The relation is of the form "class - nofInstances". Just like
    "has-relations" this relation does not need a reversed direct, since it is
    only used for making class proposals (independent of the query, especially
    in the important use case: as intilital element of a semantic query). There
    is another special property of this relation. While Right-hand-sides usually
    consist of Ids that have a match in the vocabulary, and even values are
    expressed as strigns and assigned an ID, this realtion really has numerical
    (integer) right-hand-sides. Server code should also read this realtion in a
    special way.

---------------------------- FULL-TEXT INDEX ------------------------------------

Each full-text index has the following format:
<block_1><block_2>...<block_n><metaData><offset:startOfMetaData>

Elements look like this:

    <block_i>            := <WordIds><Contexts><Scores><Positions>
    <metaData>           := <metaDataForBlock_1><metaDataForBlock_2>...<metaDataOfBlock_n>
    <metaDataForBlock_i> := <maxId><nofPostings><startWordList><startContextList>
                            <startScoreList><startPosList><posOfLastPos>

    NOTE: Using <posOfLastPos> probably was a bad idea and will have to be
    changed as soon as compression is used.


Content of blocks:

The block sizes may be chosen at will. Usually it makes sense to assign blocks
for each distinct prefix of some fixed length. Inside each block, postings are
arranged just like they are in a HYB index. However there is one special
property:

For each context in each block (note, this means ALMOST for each word-posting,
but not entirely), also all entity postings from the same context are added to the
block. The blowup factor is measured during index construction and depends on
the frequency of recognized entities. This is one of the central concepts behind
Broccoli and allows efficiently deriving comparatively small entity lists from
posting lists.


TODOs for the future (when features are implemented do not remove them
from this list, unless a description is added as well):
        - "entity occurs-with entity"-queries will required additional lists in
        the index.
        
